pipeline {
    agent {
        kubernetes {
            yaml '''
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: buildah
    image: betalabsk8sacr.azurecr.io/buildah:v1.21
    securityContext:
      privileged: true
    command:
    - cat
    tty: true  

  - name: sops
    image: betalabsk8sacr.azurecr.io/sops:v2
    command:
    - cat
    tty: true

  - name: yarn
    image: betalabsk8sacr.azurecr.io/yarn:v1.22
    resources:
      requests:
        cpu: "300m"
        memory: "2Gi"
      limits:
        cpu: "300m"
        memory: "2Gi"   
    command:
    - cat
    tty: true   
     
  - name: kubectl
    image: betalabsk8sacr.azurecr.io/kubectl:v1
    command:
    - cat
    tty: true      

  tolerations:
  - key: "kubernetes.azure.com/scalesetpriority"
    operator: "Equal"
    value: "spot"
    effect: "NoSchedule"              
'''
            defaultContainer 'shell'
        }
    }


   stages {   
      
     stage('load env') {
                  steps {
                      container('buildah') {
                      load "Jenkins/Jenkinsenv"  
                      script{  
                        def repoName = sh(returnStdout: true, script: "echo ${env.GIT_URL} | sed \'s:.*\\/::\' | sed \'s/\\.[^.]*\$//\'").trim() 
                        echo "repo: ${repoName}"   
                              //config secrets env 
                                DEPLOY = env.GIT_BRANCH == "origin/master" ? "production" : "staging"
                                HOST = env.GIT_BRANCH == "origin/master" ? "${PRD_HOST}" : "${STG_HOST}"
                                env.ENCRYPT_SEC = "devops-deployment-env/${repoName}/${DEPLOY}/${ENCRYPT_SEC}"                              
                            }                  

                          echo "env secrets: ${env.ENCRYPT_SEC}"
                          echo "branch:${GIT_BRANCH}"       
                          echo "env repo: ${GIT_ENV_REPO}"
                          echo "env file: ${env.ENCRYPT_SEC}"                                
                          }
                  }        
            }            

    stage('config secret env'){
            steps {
              container('sops') {
                    withCredentials([sshUserPrivateKey(credentialsId: "${CREDENTIALS}", keyFileVariable: 'keyfile')]) {
                        sh "mkdir ~/.ssh/"
                        sh 'ssh-agent /bin/bash' 
                        sh 'ssh-keyscan github.com  >> ~/.ssh/known_hosts' 
                        sh "eval \"\$(ssh-agent)\" && ssh-add ${keyfile} && ssh-add -l && git clone ${GIT_ENV_REPO}"      
                        }   
                      
                    withCredentials([file(credentialsId: 'jenkins-sops-pvt-key', variable: 'FILE')]) {
                        sh 'gpg --import $FILE'    
                        sh "gpg --list-keys"
                        sh "sops -d ${env.ENCRYPT_SEC} > config/${DEPLOY}/${DECRYPT_SEC}"                
                      }                               
                 sh "sops -v" 
                 sh "ls ./"
                 sh "cat ${env.ENCRYPT_SEC}"                            
                }
            }
        }


        stage('staging code build') {
              when{
                expression {
                  return env.GIT_BRANCH == "origin/staging" || env.GIT_BRANCH.contains("origin/cicd-")
                }               
              }               
            steps {
                container('yarn') {
                    sh 'pwd && ls ./'
                    sh "yarn install && yarn build"
                    sh 'ls ./'
                  }
              script{env.STAGING = 1}                
           }
        }

        stage('production code build') {
              when{
                expression {
                  return env.GIT_BRANCH == "origin/master"
                }               
              }               
            steps {
                container('yarn') {
                    sh 'pwd && ls ./'
                    sh "yarn install && yarn build"
                    //sh "yarn build"
                    sh 'ls ./'
                  } 
            script{env.PROD = 1}     
           }
        }

    stage('build image') {
      steps {
        container('buildah') {
            //get git commit hash version
            script{
                def GIT_TAG = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
                env.git_tag = "${GIT_TAG}"
                 }
            withCredentials([usernamePassword(credentialsId: 'betalabsk8sacr', passwordVariable: 'PWD', usernameVariable: 'USER')]) {
                  sh "buildah login -u=${USER} -p=${PWD} betalabsk8sacr.azurecr.io"
                  sh  "buildah bud -t ${APPIMG}:${GIT_TAG}"
                  }
        }
      }
    }

        stage('Push image') {
        steps {
            container('buildah') {
            withCredentials([usernamePassword(credentialsId: 'betalabsk8sacr', passwordVariable: 'PWD', usernameVariable: 'USER')]) {
                  sh "buildah login -u=${USER} -p=${PWD} betalabsk8sacr.azurecr.io"
                  sh "buildah push ${APPIMG}:${GIT_TAG}"
                  }            
            }
        }
    }

        stage('config deploy') {
            steps {
                container('kubectl') {                 
                    sh "sed -i -e \'s,\'_env\',\'${DEPLOY}\',g\' ${TARGET_DIR}/deploy.yaml"
                    sh "sed -i -e \'s,\'_appname\',\'${APPNAME}\',g\' ${TARGET_DIR}/deploy.yaml"
                    sh "sed -i -e \'s,\'_appport\',\'${APPPORT}\',g\' ${TARGET_DIR}/deploy.yaml"
                    sh "sed -i -e \'s,\'_appimg\',\'${APPIMG}:${GIT_TAG}\',g\' ${TARGET_DIR}/deploy.yaml"
                    sh "sed -i -e \'s,\'_host\',\'${HOST}\',g\' ${TARGET_DIR}/deploy.yaml"
                    sh "sed -i -e \'s,\'_podcmd\',\'${POD_CMD}\',g\' ${TARGET_DIR}/deploy.yaml"
                    sh "sed -i -e \'s,\'_podargs\',\'${POD_ARGS}\',g\' ${TARGET_DIR}/deploy.yaml"
                    sh "sed -i -e \'s,\'_secretPath\',\'code/config/${DEPLOY}\',g\' ${TARGET_DIR}/deploy.yaml"
                    sh "sed -i -e \'s,\'_secrets\',\'${DECRYPT_SEC}\',g\' ${TARGET_DIR}/deploy.yaml"
                    sh "sed -i -e \'s,\'_chkPath\',\'${CHK_PATH}\',g\' ${TARGET_DIR}/deploy.yaml"
                    sh "cat ${TARGET_DIR}/deploy.yaml"
                    }
                }    
            }

        stage('deploy') {
          steps {
                script {    

                         if(env.PROD >= 1) {
                            echo "production deploy"
                              container('kubectl') {
                                script{
                                    env.PROD  = 1
                                    def remote = [:]
                                    remote.name = "kubectl-server"
                                    remote.host = "${PRD_AKS}"
                                    remote.allowAnyHosts = true
                                    env.secret = "config/${DEPLOY}/${DECRYPT_SEC}"
                                    env.yaml = "${TARGET_DIR}/deploy.yaml"
                                    env.ns = "${NS}"
                                    env.appname = "${APPNAME}"

                                    withCredentials([sshUserPrivateKey(credentialsId: 'aks-hk-prod-kubctl-ssh', keyFileVariable: 'identity', passphraseVariable: '', usernameVariable: 'userName')]) {
                                    remote.user = userName
                                    remote.identityFile = identity
                                    remote.allowAnyHosts = true
                                                sshPut remote: remote, from: env.yaml , into: '.'
                                                sshPut remote: remote, from: env.secret , into: '.'
                                                sshCommand remote: remote, command: "kubectl delete secret ${DECRYPT_SEC} -n $env.ns || true"
                                                sshCommand remote: remote, command: "kubectl create secret generic ${DECRYPT_SEC} --from-file=${DECRYPT_SEC} -n $env.ns"
                                                sshCommand remote: remote, command: "kubectl apply -f deploy.yaml -n $env.ns"
                                                sshCommand remote: remote, command: "kubectl get svc -n $env.ns"
                                                sshCommand remote: remote, command: "kubectl get ing -n $env.ns"
                                                sshRemove remote: remote, path: "deploy.yaml"
                                                sshRemove remote: remote, path: "${DECRYPT_SEC}"
                                    }
                                }
                           }                          
                        } 
                        else if (env.STAGING >= 1) {
                            echo "staging deploy"
                              container('kubectl') {
                                  withCredentials([file(credentialsId: 'stg-aks-hk-config', variable: 'FILE')]) {
                                      sh "cp ${FILE} /root/.kube/"
                                  }
                                  sh "kubectl delete secret ${DECRYPT_SEC} -n ${NS} || true"
                                  sh "kubectl create secret generic ${DECRYPT_SEC} --from-file=config/${DEPLOY}/${DECRYPT_SEC} -n ${NS} || true"
                                  sh "kubectl apply -f ${TARGET_DIR}/deploy.yaml -n ${NS}"
                                  sh "kubectl get ing -n ${NS}"
                            }
                        } 
                        else if (env.STAGING < 1 && env.PROD < 1) {
                            currentBuild.result = "FAILURE"
                            echo "Deployment fails, please check."
                        }
                } 
          }  
        }

        stage('private endpoint check') {
            steps {
              //catch steps error 
              catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE'){
                script{
                         if (env.STAGING < 1 && env.PROD < 1) {
                            currentBuild.result = "FAILURE"
                            echo "Deployment fails, please check."
                        }                  
                          else if( env.STAGING >= 1){  
                              container('kubectl') {    
                                sh "sleep 60" //rolling deploy buffer             
                                POD = sh(returnStdout: true, script: "kubectl get pods -n ${NS} --sort-by=.metadata.creationTimestamp | grep ${APPNAME} | tail -n 1 | awk '{print \$1}'").trim()
                                POD_IP = sh(returnStdout: true, script: "kubectl get pods ${POD} -n ${NS} --template={{.status.podIP}}").trim()                      
                                echo "New deploy POD IP:${POD_IP}"
                                env.site = "http://${POD_IP}:${APPPORT}/${CHK_PATH}"                
                                echo "Private endpoint: ${env.site}"
                                println('URL: '+ "${env.site}")                            
                                          try{
                                              timeout(time: 30, unit: "SECONDS") {
                                              waitUntil {
                                                def SITE_CHK = sh(returnStdout: true, script: "curl -s -o /dev/null -w \"%{http_code}\" ${env.site}").trim()
                                                echo "${SITE_CHK}"
                                                return ("${SITE_CHK}" >= 200 && "${SITE_CHK}" <= 204)
                                                }
                                              }
                                          }  
                                          catch (exception) {
                                              currentBuild.result = "FAILURE"
                                              error("Private endpoint get fail status code or cannot get code")
                                          }                                
                              }
                        } 
                          else if( env.PROD >= 1){                  
                                container('kubectl') {
                                  sh "sleep 60" //rolling deploy buffer 
                                  script{
                                      def remote = [:]
                                      remote.name = "kubectl-server"
                                      remote.host = "${PRD_AKS}"
                                      remote.allowAnyHosts = true
                                      env.POD_SH = "kubectl get pods -n ${NS} --sort-by=.metadata.creationTimestamp | grep ${APPNAME} | tail -n 1 | awk '{print \$1}'"
                                      
                                      withCredentials([sshUserPrivateKey(credentialsId: 'aks-hk-prod-kubctl-ssh', keyFileVariable: 'identity', passphraseVariable: '', usernameVariable: 'userName')]) {
                                        remote.user = userName
                                        remote.identityFile = identity
                                        remote.allowAnyHosts = true
                                        def POD = sshCommand remote: remote, command: env.POD_SH, sudo: true  
                                        env.POD_IP_SH = "kubectl get pods ${POD} -n ${NS} --template={{.status.podIP}}"
                                        def POD_IP = sshCommand remote: remote, command: env.POD_IP_SH, sudo: true                                 
                                        echo "New deploy POD IP:${POD_IP}"
                                        env.site = "http://${POD_IP}:${APPPORT}/${CHK_PATH}"
                                        echo "Private endpoint: ${env.site}"
                                        env.SITECHK_SH = "curl -s -o /dev/null -w \"%{http_code}\" ${env.site}"
                                            try{
                                                timeout(time: 30, unit: "SECONDS") {
                                                waitUntil {
                                                  def SITE_CHK = sshCommand remote: remote, command: env.SITECHK_SH, sudo: true
                                                  return ("${SITE_CHK}" >= 200 && "${SITE_CHK}" <= 204) 
                                                  }
                                                }
                                            }  
                                            catch (exception) {
                                                currentBuild.result = "FAILURE"
                                                error('Private endpoint get fail status code or cannot get code')
                                            } 
                                          }
                                     }                          
                                  }
                              }
                        }      
                      }       
                    }
                  }    

 
        stage('public endpoint check') {
            steps {
                script {
                         if(env.PROD > 1) {
                            echo "production endpoint"
                            env.site = "https://${PRD_HOST}/${CHK_PATH}"
                          }
                        else if (env.STAGING > 1) {
                            echo "staging endpoint"
                            env.site = "https://${STG_HOST}/${CHK_PATH}"
                          }
                                                                              
                            println('URL: '+ "${env.site}")
                            def response = httpRequest "${env.site}"
                            println('Status: '+response.status)
                            env.httpcode = response.status
                }
            }
          } 

  }
    post {
			success {
				slackSend channel: '#jenkins',
				color: 'good',
				 message: "The pipeline ${currentBuild.fullDisplayName}, build successfully. HTTP code:${env.httpcode}. Check console result at $BUILD_URL "
				}
			failure {
				slackSend channel: '#jenkins',
				color: 'warning',
				message: "The pipeline ${currentBuild.fullDisplayName}, build failed. Check console result at $BUILD_URL."
				}  
    }
}
