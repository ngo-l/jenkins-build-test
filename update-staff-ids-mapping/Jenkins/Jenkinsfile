pipeline {
    agent {
        kubernetes {
            yaml '''
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: sops
    image: betalabsk8sacr.azurecr.io/sops:v2
    command:
    - cat
    tty: true

  - name: sls
    image: betalabsk8sacr.azurecr.io/sls_node:v14
    resources:
      requests:
        cpu: "300m"
        memory: "2Gi"
      limits:
        cpu: "300m"
        memory: "2Gi"   
    command:
    - cat
    tty: true   
    
  - name: azcli
    image: mcr.microsoft.com/azure-cli
    command:
    - cat
    tty: true       

  tolerations:
  - key: "kubernetes.azure.com/scalesetpriority"
    operator: "Equal"
    value: "spot"
    effect: "NoSchedule"              
'''
            defaultContainer 'shell'
        }
    }

      
   stages {

      stage('Check function'){
        steps{
          container('sops') {
          load "update-staff-ids-mapping/Jenkins/Jenkinsenv" 
          script{            
  
              chkDir = sh (
                  script: "git show --dirstat --oneline HEAD | grep ${SLS_DIR}",
                  returnStatus: true
                )
                try {
                  if (chkDir==0){ 
                        echo  "Function found updated, will continue to the next step"                      
                    }else{
                        error("Cannot found the function update, will abort the job")
                    }
                } catch (err) {
                    currentBuild.result = 'ABORTED'
                    error('Aborting the job and skipping notification.')
                }           
            }
          } 
        }
      } 
   

     stage('load env') {
                  steps {
                      container('azcli') {
                      sh "ls ./"                     
                      sh "cat ${SLS_DIR}/serverless.yml"

                      script{  
                        def repoName = sh(returnStdout: true, script: "echo ${env.GIT_URL} | sed \'s:.*\\/::\' | sed \'s/\\.[^.]*\$//\'").trim() 
                        echo "repo: ${repoName}"   
                              //config secrets env
                                DEPLOY = env.GIT_BRANCH == "origin/master" ? "production" : "staging"
                                env.ENCRYPT_SEC = "devops-deployment-env/elsie-serverless-functions/update-staff-ids-mapping/production/secrets.enc.env"                              
                            }                  

                          echo "env secrets: ${env.ENCRYPT_SEC}"
                          echo "branch:${GIT_BRANCH}"               
                          }
                  }        
            }            

    stage('config secret env'){
            steps {
              container('sops') {
                    withCredentials([sshUserPrivateKey(credentialsId: "${CREDENTIALS}", keyFileVariable: 'keyfile')]) {
                        sh "mkdir ~/.ssh/"
                        sh 'ssh-agent /bin/bash' 
                        sh 'ssh-keyscan github.com  >> ~/.ssh/known_hosts' 
                        sh "eval \"\$(ssh-agent)\" && ssh-add ${keyfile} && ssh-add -l && git clone ${GIT_ENV_REPO}"      
                        }   
                      
                    withCredentials([file(credentialsId: 'jenkins-sops-pvt-key', variable: 'FILE')]) {
                        sh 'gpg --import $FILE'    
                        sh "gpg --list-keys"
                        sh "sops -d ${env.ENCRYPT_SEC} > ${SLS_DIR}/${SECRET_PATH}/${DEPLOY}/${DECRYPT_SEC}"                
                      }                               
                 sh "sops -v" 
                 sh "ls ${SLS_DIR}/${SECRET_PATH}/${DEPLOY}/"
                 sh "cat ${env.ENCRYPT_SEC}"                            
                }
            }
        }

        stage('staging yarn install') {
              when{
                expression {
                  return env.GIT_BRANCH == "origin/staging" || env.GIT_BRANCH.startsWith("origin/cicd-")
                }               
              }               
            steps {
                container('sls') {
                    sh 'pwd && ls ./'                    
                    sh "cd ${SLS_DIR} && yarn install"
                  }
              script{env.STAGING = 1}                
           }
        }

        stage('production yarn install') {
              when{
                expression {
                  return env.GIT_BRANCH == "origin/master"
                }               
              }               
            steps {
                container('sls') {
                    sh 'pwd && ls ./'
                    sh "cd ${SLS_DIR} && yarn install"
                  }   
            script{env.PROD = 1}     
           }
        }

        stage('deploy') {
          steps {
                script {    

                         if(env.PROD > 1) {
                            echo "production deploy"
                            container('sls') {                     
                              withCredentials([azureServicePrincipal('azid-jenkins')]) {                       
                                sh "az login --service-principal -u ${AZURE_CLIENT_ID} -p ${AZURE_CLIENT_SECRET} --tenant ${AZURE_TENANT_ID}"
                                sh "cd ${SLS_DIR} && yarn deploy:prod"
                            }
                          }                           
                        } 
                        else if (env.STAGING > 1) {
                            echo "staging deploy"
                            container('sls') {                     
                              withCredentials([azureServicePrincipal('azid-jenkins')]) {                       
                                sh "az login --service-principal -u ${AZURE_CLIENT_ID} -p ${AZURE_CLIENT_SECRET} --tenant ${AZURE_TENANT_ID}"
                                sh "cd ${SLS_DIR} && yarn deploy:stag"
                            }
                          }
                        } 
                        else if (env.STAGING < 1 && env.PROD < 1) {
                            currentBuild.result = "FAILURE"
                            echo "Invalid env to deploy, please check branch name."
                        }
                } 
          }  
        }

        // stage('public endpoint check') {
        //     steps {
        //         script {
        //                  if(env.PROD > 1) {
        //                     echo "production endpoint"
        //                     env.site = "https://${HOST}/${API_PATH}"
        //                   }
        //                 else if (env.STAGING > 1) {
        //                     echo "staging endpoint"
        //                     env.site = "https://${STG_HOST}/${STG_API_PATH}"
        //                   }
                                                                              
        //                     println('URL: '+ "${env.site}")
        //                     def response = httpRequest "${env.site}"
        //                     println('Status: '+response.status)
        //                     env.httpcode = response.status
        //         }
        //     }
        //   } 
  }
    // post {
		// 	success {
		// 		slackSend channel: '#jenkins',
		// 		color: 'good',
		// 		 message: "The pipeline ${currentBuild.fullDisplayName}, deploy successfully. HTTP code:${env.httpcode}. Check console result at $BUILD_URL "
		// 		}
		// 	failure {
		// 		slackSend channel: '#jenkins',
		// 		color: 'warning',
		// 		message: "The pipeline ${currentBuild.fullDisplayName}, deploy failed. Check console result at $BUILD_URL."
		// 		}  
    // }
}